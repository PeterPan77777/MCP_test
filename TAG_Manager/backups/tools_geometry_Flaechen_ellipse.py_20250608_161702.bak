#!/usr/bin/env python3
"""
Ellipse-Fl√§che - Berechnet Fl√§che oder Halbachsen

Berechnet Ellipsen-Fl√§chen mit automatischer Einheiten-Konvertierung.
Alle Eingaben M√úSSEN mit Einheiten angegeben werden.

L√∂st die Formel A = œÄ √ó a √ó b nach verschiedenen Variablen auf.
L√∂sbare Variablen: flaeche, halb_achse_a, halb_achse_b

‚ö†Ô∏è NAMENSKONVENTION: ALLE Parameter-Namen M√úSSEN DEUTSCH sein!
Beispiele: durchmesser, druck, laenge, breite, hoehe, radius, flaeche, volumen, wanddicke

Ellipse: Ovale Form mit zwei Halbachsen - A = œÄ √ó a √ó b (gro√üe Halbachse √ó kleine Halbachse √ó œÄ)
"""

# ================================================================================================
# üéØ TOOL-KONFIGURATION & PARAMETER-DEFINITIONEN üéØ
# ================================================================================================

# ===== üîß GRUNDKONFIGURATION =====
TOOL_NAME = "ellipse_flaeche"
TOOL_TAGS = ["elementar", "Flaechen"]
TOOL_SHORT_DESCRIPTION = "Ellipse-Fl√§che - Berechnet Fl√§che oder Halbachsen"
TOOL_VERSION = "1.0.0"
HAS_SOLVING = "symbolic/numeric"  # Fl√§che analytisch, Halbachsen numerisch

# ===== üìù FUNKTIONSPARAMETER-DEFINITIONEN =====
FUNCTION_PARAM_1_NAME = "flaeche"
FUNCTION_PARAM_1_DESC = "Fl√§che der Ellipse mit Fl√§cheneinheit (z.B. '78.54 cm¬≤', '0.007854 m¬≤', '7854 mm¬≤') oder 'target' f√ºr Berechnung"
FUNCTION_PARAM_1_EXAMPLE = "78.54 cm¬≤"

FUNCTION_PARAM_2_NAME = "halb_achse_a"
FUNCTION_PARAM_2_DESC = "Gro√üe Halbachse der Ellipse mit L√§ngeneinheit (z.B. '5 cm', '50 mm', '0.05 m') oder 'target' f√ºr Berechnung"
FUNCTION_PARAM_2_EXAMPLE = "5 cm"

FUNCTION_PARAM_3_NAME = "halb_achse_b"
FUNCTION_PARAM_3_DESC = "Kleine Halbachse der Ellipse mit L√§ngeneinheit (z.B. '3 cm', '30 mm', '0.03 m') oder 'target' f√ºr Berechnung"
FUNCTION_PARAM_3_EXAMPLE = "3 cm"

# ===== üìä METADATEN-STRUKTUR =====
TOOL_DESCRIPTION = f"""L√∂st die Ellipsenformel A = œÄ √ó a √ó b nach verschiedenen Variablen auf mit TARGET-System.

WICHTIG: Alle Parameter sind PFLICHT - einer als 'target', die anderen mit Einheiten!
Target-System: Geben Sie 'target' f√ºr den zu berechnenden Parameter an.

BERECHNUNGSARTEN:
{FUNCTION_PARAM_1_NAME}: ANALYTISCHE L√ñSUNG (geschlossene Formel A = œÄ √ó a √ó b)
{FUNCTION_PARAM_2_NAME}: NUMERISCHE ITERATION (Bisektionsverfahren f√ºr a = A / (œÄ √ó b))
{FUNCTION_PARAM_3_NAME}: NUMERISCHE ITERATION (Bisektionsverfahren f√ºr b = A / (œÄ √ó a))

Ellipsenformel: A = œÄ √ó a √ó b

Anwendungsbereich: Geometrie, Maschinenbau (Ovale √ñffnungen), Architektur, Fl√§chenberechnungen
Einschr√§nkungen: Alle Werte m√ºssen positiv sein, gro√üe Halbachse ‚â• kleine Halbachse
Genauigkeit: Analytisch exakt, numerisch 1√ó10‚Åª¬π‚Å∞ m Toleranz"""

# Parameter-Definitionen f√ºr Metadaten
PARAMETER_FLAECHE = {
    "type": "string",
    "description": FUNCTION_PARAM_1_DESC,
    "example": FUNCTION_PARAM_1_EXAMPLE
}

PARAMETER_HALB_ACHSE_A = {
    "type": "string", 
    "description": FUNCTION_PARAM_2_DESC,
    "example": FUNCTION_PARAM_2_EXAMPLE
}

PARAMETER_HALB_ACHSE_B = {
    "type": "string",
    "description": FUNCTION_PARAM_3_DESC,
    "example": FUNCTION_PARAM_3_EXAMPLE
}

# Output-Definition
OUTPUT_RESULT = {
    "type": "Quantity",
    "description": "Berechnungsergebnis mit optimierter Einheit",
    "unit": "abh√§ngig vom Parameter"
}

# Beispiele (verwenden die definierten Parameter-Namen)
TOOL_EXAMPLES = [
    {
        "title": f"Berechne {FUNCTION_PARAM_1_NAME} (analytisch) bei gegebenen {FUNCTION_PARAM_2_NAME} und {FUNCTION_PARAM_3_NAME}",
        "input": {FUNCTION_PARAM_1_NAME: "target", FUNCTION_PARAM_2_NAME: FUNCTION_PARAM_2_EXAMPLE, FUNCTION_PARAM_3_NAME: FUNCTION_PARAM_3_EXAMPLE},
        "output": f"{FUNCTION_PARAM_1_NAME} in optimierter Einheit mit geschlossener Formel"
    },
    {
        "title": f"Berechne {FUNCTION_PARAM_2_NAME} (numerisch) bei gegebenen {FUNCTION_PARAM_1_NAME} und {FUNCTION_PARAM_3_NAME}", 
        "input": {FUNCTION_PARAM_1_NAME: "47.12 cm¬≤", FUNCTION_PARAM_2_NAME: "target", FUNCTION_PARAM_3_NAME: FUNCTION_PARAM_3_EXAMPLE},
        "output": f"{FUNCTION_PARAM_2_NAME} in optimierter Einheit mit numerischer Iteration"
    },
    {
        "title": f"Berechne {FUNCTION_PARAM_3_NAME} (numerisch) bei gegebenen {FUNCTION_PARAM_1_NAME} und {FUNCTION_PARAM_2_NAME}",
        "input": {FUNCTION_PARAM_1_NAME: "47.12 cm¬≤", FUNCTION_PARAM_2_NAME: FUNCTION_PARAM_2_EXAMPLE, FUNCTION_PARAM_3_NAME: "target"},
        "output": f"{FUNCTION_PARAM_3_NAME} in optimierter Einheit mit numerischer Iteration"
    }
]

# Annahmen
TOOL_ASSUMPTIONS = [
    "Ellipse mit zwei bekannten Halbachsen",
    "Alle Eingabewerte sind positiv",
    "Gro√üe Halbachse ‚â• kleine Halbachse"
]

# Einschr√§nkungen  
TOOL_LIMITATIONS = [
    "Nur f√ºr positive Werte g√ºltig",
    "Gro√üe Halbachse muss gr√∂√üer oder gleich der kleinen Halbachse sein",
    "Nicht f√ºr Kreise optimiert (verwenden Sie Kreis-Tool)"
]

# Mathematische Grundlagen
MATHEMATICAL_FOUNDATION = "Ellipsenformel: A = œÄ √ó a √ó b, wobei a die gro√üe und b die kleine Halbachse ist"

# Normengrundlage
NORM_FOUNDATION = ""

# ===== AUTOMATISCH BERECHNET =====
PARAMETER_COUNT = len([name for name in globals() if name.startswith('PARAMETER_')])

# ================================================================================================
# üîß IMPORTS & DEPENDENCIES üîß
# ================================================================================================

from typing import Dict, Annotated
import sys
import os
import math

# Import des Einheiten-Utilities
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from engineering_mcp.units_utils import validate_inputs_have_units, optimize_output_unit, UnitsError, ureg

# ================================================================================================
# üéØ TOOL FUNCTIONS üéØ
# ================================================================================================

def solve_semi_axis_numerically(target_value_si, other_axis_si, is_major_axis=True, tolerance=1e-10, max_iterations=100):
    """
    L√∂st numerisch nach Halbachse auf: A = œÄ √ó a √ó b
    - Bei is_major_axis=True: l√∂st nach gro√üer Halbachse a = A / (œÄ √ó b)
    - Bei is_major_axis=False: l√∂st nach kleiner Halbachse b = A / (œÄ √ó a)
    """
    def ellipse_area(axis):
        if is_major_axis:
            return math.pi * axis * other_axis_si
        else:
            return math.pi * other_axis_si * axis
    
    # Bisektionsverfahren
    lower = 1e-12  # Sehr kleine positive Zahl
    upper = target_value_si / (math.pi * other_axis_si) * 10  # Gro√ü genug f√ºr jede realistische Ellipse
    
    for iteration in range(max_iterations):
        mid = (lower + upper) / 2
        calculated_area = ellipse_area(mid)
        
        if abs(calculated_area - target_value_si) < tolerance:
            return mid, iteration + 1, abs(calculated_area - target_value_si)
        
        if calculated_area < target_value_si:
            lower = mid
        else:
            upper = mid
    
    return mid, max_iterations, abs(ellipse_area(mid) - target_value_si)

def solve_ellipse(
    # ‚ö†Ô∏è Hier die konfigurierten Parameter-Namen und -Beschreibungen verwenden:
    flaeche: Annotated[str, FUNCTION_PARAM_1_DESC],  
    halb_achse_a: Annotated[str, FUNCTION_PARAM_2_DESC],
    halb_achse_b: Annotated[str, FUNCTION_PARAM_3_DESC]
) -> Dict:
    """
    L√∂st die Ellipsenformel A = œÄ √ó a √ó b nach verschiedenen Variablen auf.
    
    Verwendet die oben definierten Parameter-Konfigurationen f√ºr konsistente 
    Beschreibungen und Beispiele.
    """
    try:
        # Identifiziere target Parameter
        target_params = []
        given_params = []
        
        params_info = {
            'var1': flaeche,
            'var2': halb_achse_a, 
            'var3': halb_achse_b
        }
        
        for param_name, param_value in params_info.items():
            if param_value.lower().strip() == "target":
                target_params.append(param_name)
            else:
                given_params.append(param_name)
        
        # Validierung: Genau ein target Parameter
        if len(target_params) != 1:
            return {
                "error": f"Genau ein Parameter muss 'target' sein (gefunden: {len(target_params)})",
                "target_params": target_params,
                "example": f"solve_ellipse({FUNCTION_PARAM_1_NAME}='target', {FUNCTION_PARAM_2_NAME}='{FUNCTION_PARAM_2_EXAMPLE}', {FUNCTION_PARAM_3_NAME}='{FUNCTION_PARAM_3_EXAMPLE}')",
                "hinweis": "Geben Sie genau einen Parameter als 'target' an"
            }
        
        if len(given_params) != 2:
            return {
                "error": f"Genau 2 Parameter m√ºssen Werte mit Einheiten haben (gefunden: {len(given_params)})",
                "given_params": given_params,
                "example": f"solve_ellipse({FUNCTION_PARAM_1_NAME}='target', {FUNCTION_PARAM_2_NAME}='{FUNCTION_PARAM_2_EXAMPLE}', {FUNCTION_PARAM_3_NAME}='{FUNCTION_PARAM_3_EXAMPLE}')"
            }
        
        target_param = target_params[0]
        
        # Erstelle kwargs f√ºr Validierung (nur gegebene Parameter)
        validation_kwargs = {}
        param_names = {
            'var1': 'flaeche',
            'var2': 'halb_achse_a', 
            'var3': 'halb_achse_b'
        }
        
        for param_name in given_params:
            real_param_name = param_names[param_name]
            validation_kwargs[real_param_name] = params_info[param_name]

        # Validierung der Eingaben
        try:
            params = validate_inputs_have_units(**validation_kwargs)
        except UnitsError as e:
            return {
                "error": "Einheiten-Fehler",
                "message": str(e),
                "hinweis": "Alle Nicht-Target-Parameter m√ºssen mit Einheiten angegeben werden",
                "beispiele": [
                    f"{FUNCTION_PARAM_1_NAME}='{FUNCTION_PARAM_1_EXAMPLE}'",
                    f"{FUNCTION_PARAM_2_NAME}='{FUNCTION_PARAM_2_EXAMPLE}'", 
                    f"{FUNCTION_PARAM_3_NAME}='{FUNCTION_PARAM_3_EXAMPLE}'"
                ]
            }
        
        # Berechnung basierend auf target Parameter
        if target_param == 'var1':  # flaeche
            # Berechne Fl√§che: A = œÄ √ó a √ó b
            a_si = params['halb_achse_a']['si_value']
            b_si = params['halb_achse_b']['si_value']
            
            if a_si <= 0 or b_si <= 0:
                return {"error": "Alle Werte m√ºssen positiv sein"}
            
            flaeche_si = math.pi * a_si * b_si
            
            # Optimiere Ausgabe-Einheit
            ref_unit = params['halb_achse_b']['original_unit'] if b_si < a_si else params['halb_achse_a']['original_unit']
            flaeche_quantity = flaeche_si * ureg.meter**2
            flaeche_optimized = optimize_output_unit(flaeche_quantity, ref_unit)
            
            return {
                "üìä ANALYTICAL SOLUTION": "Geschlossene Formel",
                "target_parameter": "flaeche",
                "gegebene_werte": {
                    "grosse_halbachse": halb_achse_a,
                    "kleine_halbachse": halb_achse_b
                },
                "ergebnis": {
                    "flaeche": f"{flaeche_optimized.magnitude:.6g} {flaeche_optimized.units}"
                },
                "formel": "A = œÄ √ó a √ó b",
                "si_werte": {
                    "flaeche_si": f"{flaeche_si:.6g} m¬≤",
                    "grosse_halbachse_si": f"{a_si:.6g} m",
                    "kleine_halbachse_si": f"{b_si:.6g} m"
                }
            }
            
        elif target_param == 'var2':  # halb_achse_a
            # Berechne gro√üe Halbachse numerisch: a = A / (œÄ √ó b)
            flaeche_si = params['flaeche']['si_value']
            b_si = params['halb_achse_b']['si_value']
            
            if flaeche_si <= 0 or b_si <= 0:
                return {"error": "Alle Werte m√ºssen positiv sein"}
            
            a_si, iterations, error_estimate = solve_semi_axis_numerically(flaeche_si, b_si, is_major_axis=True)
            
            # Geometrische Validierung: gro√üe Halbachse muss >= kleine Halbachse sein
            if a_si < b_si * 0.99:  # 1% Toleranz f√ºr numerische Ungenauigkeiten
                return {
                    "error": "Geometrisch inkonsistent: Gro√üe Halbachse w√§re kleiner als kleine Halbachse",
                    "berechnete_grosse_halbachse": f"{a_si:.6g} m",
                    "kleine_halbachse": f"{b_si:.6g} m",
                    "hinweis": "√úberpr√ºfen Sie die Eingabewerte"
                }
            
            # Optimiere Ausgabe-Einheit
            ref_unit = params['halb_achse_b']['original_unit']
            a_quantity = a_si * ureg.meter
            a_optimized = optimize_output_unit(a_quantity, ref_unit)
            
            return {
                "üî¢ NUMERICAL ITERATION": "Bisektionsverfahren",
                "target_parameter": "halb_achse_a",
                "gegebene_werte": {
                    "flaeche": flaeche,
                    "kleine_halbachse": halb_achse_b
                },
                "ergebnis": {
                    "grosse_halbachse": f"{a_optimized.magnitude:.6g} {a_optimized.units}"
                },
                "formel": "a = A / (œÄ √ó b)",
                "numerische_details": {
                    "iterationen": iterations,
                    "toleranz": "1√ó10‚Åª¬π‚Å∞ m",
                    "fehlerabschaetzung": f"{error_estimate:.2e} m¬≤"
                },
                "si_werte": {
                    "grosse_halbachse_si": f"{a_si:.6g} m",
                    "flaeche_si": f"{flaeche_si:.6g} m¬≤",
                    "kleine_halbachse_si": f"{b_si:.6g} m"
                }
            }
            
        elif target_param == 'var3':  # halb_achse_b
            # Berechne kleine Halbachse numerisch: b = A / (œÄ √ó a)
            flaeche_si = params['flaeche']['si_value']
            a_si = params['halb_achse_a']['si_value']
            
            if flaeche_si <= 0 or a_si <= 0:
                return {"error": "Alle Werte m√ºssen positiv sein"}
            
            b_si, iterations, error_estimate = solve_semi_axis_numerically(flaeche_si, a_si, is_major_axis=False)
            
            # Geometrische Validierung: kleine Halbachse muss <= gro√üe Halbachse sein
            if b_si > a_si * 1.01:  # 1% Toleranz f√ºr numerische Ungenauigkeiten
                return {
                    "error": "Geometrisch inkonsistent: Kleine Halbachse w√§re gr√∂√üer als gro√üe Halbachse",
                    "berechnete_kleine_halbachse": f"{b_si:.6g} m",
                    "grosse_halbachse": f"{a_si:.6g} m",
                    "hinweis": "√úberpr√ºfen Sie die Eingabewerte"
                }
            
            # Optimiere Ausgabe-Einheit
            ref_unit = params['halb_achse_a']['original_unit']
            b_quantity = b_si * ureg.meter
            b_optimized = optimize_output_unit(b_quantity, ref_unit)
            
            return {
                "üî¢ NUMERICAL ITERATION": "Bisektionsverfahren",
                "target_parameter": "halb_achse_b",
                "gegebene_werte": {
                    "flaeche": flaeche,
                    "grosse_halbachse": halb_achse_a
                },
                "ergebnis": {
                    "kleine_halbachse": f"{b_optimized.magnitude:.6g} {b_optimized.units}"
                },
                "formel": "b = A / (œÄ √ó a)",
                "numerische_details": {
                    "iterationen": iterations,
                    "toleranz": "1√ó10‚Åª¬π‚Å∞ m",
                    "fehlerabschaetzung": f"{error_estimate:.2e} m¬≤"
                },
                "si_werte": {
                    "kleine_halbachse_si": f"{b_si:.6g} m",
                    "flaeche_si": f"{flaeche_si:.6g} m¬≤",
                    "grosse_halbachse_si": f"{a_si:.6g} m"
                }
            }
        
    except UnitsError as e:
        return {"error": f"Einheiten-Fehler: {str(e)}"}
    except Exception as e:
        return {
            "error": f"Fehler in solve_ellipse: {str(e)}",
            "type": type(e).__name__
        }

# ================================================================================================
# üéØ METADATA FUNCTIONS üéØ
# ================================================================================================

def get_metadata():
    """Gibt die Metadaten des Tools f√ºr Registry-Discovery zur√ºck"""
    return {
        # ‚úÖ Neue Registry-Struktur
        "tool_name": TOOL_NAME,
        "short_description": TOOL_SHORT_DESCRIPTION,  # ‚úÖ Neu
        "description": TOOL_DESCRIPTION,  # ‚úÖ Neu
        "tags": TOOL_TAGS,  # ‚úÖ Neu: "tags" statt "tool_tags"
        "has_solving": HAS_SOLVING,
        
        # ‚úÖ KRITISCH: Parameters Dictionary f√ºr Registry-Discovery
        "parameters": {
            FUNCTION_PARAM_1_NAME: PARAMETER_FLAECHE,
            FUNCTION_PARAM_2_NAME: PARAMETER_HALB_ACHSE_A,
            FUNCTION_PARAM_3_NAME: PARAMETER_HALB_ACHSE_B,
        },
        
        # ‚úÖ Beispiele im neuen Format
        "examples": TOOL_EXAMPLES,
        
        # ‚úÖ Vollst√§ndige Metadaten f√ºr erweiterte Nutzung
        "tool_version": TOOL_VERSION,
        "output_result": OUTPUT_RESULT,
        "tool_assumptions": TOOL_ASSUMPTIONS,
        "tool_limitations": TOOL_LIMITATIONS,
        "mathematical_foundation": MATHEMATICAL_FOUNDATION,
        "norm_foundation": NORM_FOUNDATION,
        
        # ‚úÖ Backwards Compatibility (falls andere Teile das alte Format erwarten)
        "tool_tags": TOOL_TAGS,
        "tool_short_description": TOOL_SHORT_DESCRIPTION,
        "parameter_count": len([name for name in globals() if name.startswith('PARAMETER_')]),
        "tool_description": TOOL_DESCRIPTION,
        "parameter_count": PARAMETER_COUNT,
        "parameter_flaeche": PARAMETER_FLAECHE,
        "parameter_halb_achse_a": PARAMETER_HALB_ACHSE_A,
        "parameter_halb_achse_b": PARAMETER_HALB_ACHSE_B
    }

def calculate(flaeche: str, halb_achse_a: str, halb_achse_b: str) -> Dict:
    """Legacy-Funktion f√ºr Kompatibilit√§t"""
    return solve_ellipse(flaeche, halb_achse_a, halb_achse_b) 